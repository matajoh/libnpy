<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libnpy: npy::tensor&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libnpy<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Lightweight C++ library for reading and writing NPY and NPZ files</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenpy.html">npy</a></li><li class="navelem"><a class="el" href="classnpy_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classnpy_1_1tensor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">npy::tensor&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The default tensor class.  
 <a href="classnpy_1_1tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="npy_8h_source.html">npy.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:accf3685dd37c104848c6187a24f0d293" id="r_accf3685dd37c104848c6187a24f0d293"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a></td></tr>
<tr class="memdesc:accf3685dd37c104848c6187a24f0d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of the tensor.  <br /></td></tr>
<tr class="separator:accf3685dd37c104848c6187a24f0d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8c81df709fd6ceaaea5897e5a8a505" id="r_aef8c81df709fd6ceaaea5897e5a8a505"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aef8c81df709fd6ceaaea5897e5a8a505">reference</a></td></tr>
<tr class="memdesc:aef8c81df709fd6ceaaea5897e5a8a505"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the tensor.  <br /></td></tr>
<tr class="separator:aef8c81df709fd6ceaaea5897e5a8a505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce0c9c2f11be941c9a14ff078561268" id="r_a2ce0c9c2f11be941c9a14ff078561268"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a2ce0c9c2f11be941c9a14ff078561268">const_reference</a></td></tr>
<tr class="memdesc:a2ce0c9c2f11be941c9a14ff078561268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const reference type of the tensor.  <br /></td></tr>
<tr class="separator:a2ce0c9c2f11be941c9a14ff078561268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670a9d4fceac896ad00f7a60fb8b9329" id="r_a670a9d4fceac896ad00f7a60fb8b9329"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a670a9d4fceac896ad00f7a60fb8b9329">pointer</a></td></tr>
<tr class="memdesc:a670a9d4fceac896ad00f7a60fb8b9329"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer type of the tensor.  <br /></td></tr>
<tr class="separator:a670a9d4fceac896ad00f7a60fb8b9329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401aa99066711454331a8ce24101bec6" id="r_a401aa99066711454331a8ce24101bec6"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a401aa99066711454331a8ce24101bec6">const_pointer</a></td></tr>
<tr class="memdesc:a401aa99066711454331a8ce24101bec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const pointer type of the tensor.  <br /></td></tr>
<tr class="separator:a401aa99066711454331a8ce24101bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa89eed957cb3d7d05165a49054a18cf9" id="r_aa89eed957cb3d7d05165a49054a18cf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aa89eed957cb3d7d05165a49054a18cf9">tensor</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classnpy_1_1tensor.html#ad0e71ad970c20cae0249e1837e2801cc">shape</a>)</td></tr>
<tr class="memdesc:aa89eed957cb3d7d05165a49054a18cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aa89eed957cb3d7d05165a49054a18cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48d6e6c3a97ea27caf0622449fc7515" id="r_aa48d6e6c3a97ea27caf0622449fc7515"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aa48d6e6c3a97ea27caf0622449fc7515">tensor</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classnpy_1_1tensor.html#ad0e71ad970c20cae0249e1837e2801cc">shape</a>, bool <a class="el" href="classnpy_1_1tensor.html#a684c3c76eebb2bed2485703829034a59">fortran_order</a>)</td></tr>
<tr class="memdesc:aa48d6e6c3a97ea27caf0622449fc7515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aa48d6e6c3a97ea27caf0622449fc7515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff814b1db2bab48f966bf49a4d6a4a6c" id="r_aff814b1db2bab48f966bf49a4d6a4a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aff814b1db2bab48f966bf49a4d6a4a6c">tensor</a> (const <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aff814b1db2bab48f966bf49a4d6a4a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:aff814b1db2bab48f966bf49a4d6a4a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac650cb70b8437300946464629f50183b" id="r_ac650cb70b8437300946464629f50183b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ac650cb70b8437300946464629f50183b">tensor</a> (<a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ac650cb70b8437300946464629f50183b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:ac650cb70b8437300946464629f50183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0907fa4f35f3dbe9ce0367448dad82" id="r_a2c0907fa4f35f3dbe9ce0367448dad82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a2c0907fa4f35f3dbe9ce0367448dad82">save</a> (std::basic_ostream&lt; char &gt; &amp;output, <a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a> endianness) const</td></tr>
<tr class="memdesc:a2c0907fa4f35f3dbe9ce0367448dad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the tensor to the provided stream.  <br /></td></tr>
<tr class="separator:a2c0907fa4f35f3dbe9ce0367448dad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e34e7f2b84c94ee871e2a72f493055e" id="r_a3e34e7f2b84c94ee871e2a72f493055e"><td class="memTemplParams" colspan="2">template&lt;typename... Indices&gt; </td></tr>
<tr class="memitem:a3e34e7f2b84c94ee871e2a72f493055e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a3e34e7f2b84c94ee871e2a72f493055e">operator()</a> (Indices... index) const</td></tr>
<tr class="memdesc:a3e34e7f2b84c94ee871e2a72f493055e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable parameter index function.  <br /></td></tr>
<tr class="separator:a3e34e7f2b84c94ee871e2a72f493055e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7da18581a6d8001d362c5c9e3c4929" id="r_abd7da18581a6d8001d362c5c9e3c4929"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#abd7da18581a6d8001d362c5c9e3c4929">operator()</a> (const std::vector&lt; std::size_t &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:abd7da18581a6d8001d362c5c9e3c4929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index function.  <br /></td></tr>
<tr class="separator:abd7da18581a6d8001d362c5c9e3c4929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61dc8394da8a758a4861203aa5f93d6" id="r_aa61dc8394da8a758a4861203aa5f93d6"><td class="memTemplParams" colspan="2">template&lt;typename... Indices&gt; </td></tr>
<tr class="memitem:aa61dc8394da8a758a4861203aa5f93d6"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aa61dc8394da8a758a4861203aa5f93d6">operator()</a> (Indices... index)</td></tr>
<tr class="memdesc:aa61dc8394da8a758a4861203aa5f93d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable parameter index function.  <br /></td></tr>
<tr class="separator:aa61dc8394da8a758a4861203aa5f93d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f52776e4240990d1a5c25ace6ca4f04" id="r_a4f52776e4240990d1a5c25ace6ca4f04"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a4f52776e4240990d1a5c25ace6ca4f04">operator()</a> (const std::vector&lt; std::size_t &gt; &amp;multi_index)</td></tr>
<tr class="memdesc:a4f52776e4240990d1a5c25ace6ca4f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index function.  <br /></td></tr>
<tr class="separator:a4f52776e4240990d1a5c25ace6ca4f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a576bc55c8bd02ec09797f46d74af9" id="r_ad2a576bc55c8bd02ec09797f46d74af9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ad2a576bc55c8bd02ec09797f46d74af9">begin</a> ()</td></tr>
<tr class="memdesc:ad2a576bc55c8bd02ec09797f46d74af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing at the beginning of the tensor in memory.  <br /></td></tr>
<tr class="separator:ad2a576bc55c8bd02ec09797f46d74af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65878d7b654fe3e31e01b24eb4cd215d" id="r_a65878d7b654fe3e31e01b24eb4cd215d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a65878d7b654fe3e31e01b24eb4cd215d">begin</a> () const</td></tr>
<tr class="memdesc:a65878d7b654fe3e31e01b24eb4cd215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing at the beginning of the tensor in memory.  <br /></td></tr>
<tr class="separator:a65878d7b654fe3e31e01b24eb4cd215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e268854d182b405913911fbf8a25f" id="r_a346e268854d182b405913911fbf8a25f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a346e268854d182b405913911fbf8a25f">end</a> ()</td></tr>
<tr class="memdesc:a346e268854d182b405913911fbf8a25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing at the end of the tensor in memory.  <br /></td></tr>
<tr class="separator:a346e268854d182b405913911fbf8a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede3f4f51109b38a1f59bff95e196990" id="r_aede3f4f51109b38a1f59bff95e196990"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aede3f4f51109b38a1f59bff95e196990">end</a> () const</td></tr>
<tr class="memdesc:aede3f4f51109b38a1f59bff95e196990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing at the end of the tensor in memory.  <br /></td></tr>
<tr class="separator:aede3f4f51109b38a1f59bff95e196990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852f677cec2b73684f503b09b5d6307f" id="r_a852f677cec2b73684f503b09b5d6307f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a852f677cec2b73684f503b09b5d6307f">set</a> (const std::vector&lt; std::int32_t &gt; &amp;multi_index, const T &amp;value)</td></tr>
<tr class="memdesc:a852f677cec2b73684f503b09b5d6307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value at the provided index.  <br /></td></tr>
<tr class="separator:a852f677cec2b73684f503b09b5d6307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d4def2efb612cc8c6d8ab421601440" id="r_a20d4def2efb612cc8c6d8ab421601440"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a20d4def2efb612cc8c6d8ab421601440">get</a> (const std::vector&lt; std::int32_t &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:a20d4def2efb612cc8c6d8ab421601440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value at the provided index.  <br /></td></tr>
<tr class="separator:a20d4def2efb612cc8c6d8ab421601440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac215c34c837038ed563b0ad6b424431" id="r_aac215c34c837038ed563b0ad6b424431"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aac215c34c837038ed563b0ad6b424431">dtype</a> (<a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a> endianness) const</td></tr>
<tr class="memdesc:aac215c34c837038ed563b0ad6b424431"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type of the tensor.  <br /></td></tr>
<tr class="separator:aac215c34c837038ed563b0ad6b424431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4406177bbae28349fc2eacae193215" id="r_a3b4406177bbae28349fc2eacae193215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenpy.html#abae1d42f0957bb3a28b51128159a69c3">data_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a3b4406177bbae28349fc2eacae193215">dtype</a> () const</td></tr>
<tr class="memdesc:a3b4406177bbae28349fc2eacae193215"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type of the tensor.  <br /></td></tr>
<tr class="separator:a3b4406177bbae28349fc2eacae193215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ab458c84f0549031108312804b875a" id="r_af6ab458c84f0549031108312804b875a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#af6ab458c84f0549031108312804b875a">values</a> () const</td></tr>
<tr class="memdesc:af6ab458c84f0549031108312804b875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying values buffer.  <br /></td></tr>
<tr class="separator:af6ab458c84f0549031108312804b875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128dc5d7bea3eaba210f68c31b81a2c5" id="r_a128dc5d7bea3eaba210f68c31b81a2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a128dc5d7bea3eaba210f68c31b81a2c5">copy_from</a> (const T *source, size_t nitems)</td></tr>
<tr class="memdesc:a128dc5d7bea3eaba210f68c31b81a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy values from the source to this tensor.  <br /></td></tr>
<tr class="separator:a128dc5d7bea3eaba210f68c31b81a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677e9f20de0d4a10d983a13aaa2af789" id="r_a677e9f20de0d4a10d983a13aaa2af789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a677e9f20de0d4a10d983a13aaa2af789">copy_from</a> (const std::vector&lt; T &gt; &amp;source)</td></tr>
<tr class="memdesc:a677e9f20de0d4a10d983a13aaa2af789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy values from the provided vector.  <br /></td></tr>
<tr class="separator:a677e9f20de0d4a10d983a13aaa2af789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81804e27c8b96acbf92ab468243bf9c" id="r_aa81804e27c8b96acbf92ab468243bf9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aa81804e27c8b96acbf92ab468243bf9c">move_from</a> (std::vector&lt; T &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:aa81804e27c8b96acbf92ab468243bf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move values from the provided vector.  <br /></td></tr>
<tr class="separator:aa81804e27c8b96acbf92ab468243bf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c366139a18b6410b69e1cde08a152d" id="r_a01c366139a18b6410b69e1cde08a152d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a01c366139a18b6410b69e1cde08a152d">data</a> ()</td></tr>
<tr class="memdesc:a01c366139a18b6410b69e1cde08a152d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the start of the underlying values buffer.  <br /></td></tr>
<tr class="separator:a01c366139a18b6410b69e1cde08a152d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae9b26c0c5d2c7c5d5f99a325c4d39e" id="r_acae9b26c0c5d2c7c5d5f99a325c4d39e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#acae9b26c0c5d2c7c5d5f99a325c4d39e">data</a> () const</td></tr>
<tr class="memdesc:acae9b26c0c5d2c7c5d5f99a325c4d39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the start of the underlying values buffer.  <br /></td></tr>
<tr class="separator:acae9b26c0c5d2c7c5d5f99a325c4d39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfe2df7ec8257993f958e10e7febbde" id="r_afdfe2df7ec8257993f958e10e7febbde"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#afdfe2df7ec8257993f958e10e7febbde">size</a> () const</td></tr>
<tr class="memdesc:afdfe2df7ec8257993f958e10e7febbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in the tensor.  <br /></td></tr>
<tr class="separator:afdfe2df7ec8257993f958e10e7febbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e71ad970c20cae0249e1837e2801cc" id="r_ad0e71ad970c20cae0249e1837e2801cc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ad0e71ad970c20cae0249e1837e2801cc">shape</a> () const</td></tr>
<tr class="memdesc:ad0e71ad970c20cae0249e1837e2801cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shape of the vector. Each element is the size of the corresponding dimension.  <br /></td></tr>
<tr class="separator:ad0e71ad970c20cae0249e1837e2801cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addae64781a15cfc41c1136e921ec9cf8" id="r_addae64781a15cfc41c1136e921ec9cf8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#addae64781a15cfc41c1136e921ec9cf8">shape</a> (int index) const</td></tr>
<tr class="memdesc:addae64781a15cfc41c1136e921ec9cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimensionality of the tensor at the specified index.  <br /></td></tr>
<tr class="separator:addae64781a15cfc41c1136e921ec9cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3832b2cb1c9314abdfcaac2323967ae" id="r_ad3832b2cb1c9314abdfcaac2323967ae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ad3832b2cb1c9314abdfcaac2323967ae">ndim</a> () const</td></tr>
<tr class="memdesc:ad3832b2cb1c9314abdfcaac2323967ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dimensions of the tensor.  <br /></td></tr>
<tr class="separator:ad3832b2cb1c9314abdfcaac2323967ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684c3c76eebb2bed2485703829034a59" id="r_a684c3c76eebb2bed2485703829034a59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a684c3c76eebb2bed2485703829034a59">fortran_order</a> () const</td></tr>
<tr class="memdesc:a684c3c76eebb2bed2485703829034a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the tensor data is stored in FORTRAN, or column-major, order.  <br /></td></tr>
<tr class="separator:a684c3c76eebb2bed2485703829034a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da21281dc501498c45ddde8b03d85ae" id="r_a9da21281dc501498c45ddde8b03d85ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a9da21281dc501498c45ddde8b03d85ae">operator=</a> (const <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a9da21281dc501498c45ddde8b03d85ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a9da21281dc501498c45ddde8b03d85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa157cbf37cedb6a7d700e53717e9b7" id="r_abaa157cbf37cedb6a7d700e53717e9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#abaa157cbf37cedb6a7d700e53717e9b7">operator=</a> (<a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:abaa157cbf37cedb6a7d700e53717e9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:abaa157cbf37cedb6a7d700e53717e9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaf78cbfe64e16fa610642eb179ee43" id="r_adcaf78cbfe64e16fa610642eb179ee43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#adcaf78cbfe64e16fa610642eb179ee43">save</a> (const std::string &amp;path, <a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a> endianness=<a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11af78504d96ba7177dc0c6784905ac8743">npy::endian_t::NATIVE</a>)</td></tr>
<tr class="memdesc:adcaf78cbfe64e16fa610642eb179ee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save this tensor to the provided location on disk.  <br /></td></tr>
<tr class="separator:adcaf78cbfe64e16fa610642eb179ee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d66816cf6a207a3f2fd4f5dc8a0b23" id="r_ad8d66816cf6a207a3f2fd4f5dc8a0b23"><td class="memTemplParams" colspan="2">template&lt;class INDEX_IT , class SHAPE_IT &gt; </td></tr>
<tr class="memitem:ad8d66816cf6a207a3f2fd4f5dc8a0b23"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ad8d66816cf6a207a3f2fd4f5dc8a0b23">ravel</a> (INDEX_IT index, SHAPE_IT <a class="el" href="classnpy_1_1tensor.html#ad0e71ad970c20cae0249e1837e2801cc">shape</a>) const</td></tr>
<tr class="memdesc:ad8d66816cf6a207a3f2fd4f5dc8a0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ravels a multi-index into a single value indexing the buffer.  <br /></td></tr>
<tr class="separator:ad8d66816cf6a207a3f2fd4f5dc8a0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b03726545f2d2445ea4ce854520731" id="r_aa1b03726545f2d2445ea4ce854520731"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#aa1b03726545f2d2445ea4ce854520731">ravel</a> (const std::vector&lt; std::int32_t &gt; &amp;multi_index) const</td></tr>
<tr class="memdesc:aa1b03726545f2d2445ea4ce854520731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ravels a multi-index into a single value indexing the buffer.  <br /></td></tr>
<tr class="separator:aa1b03726545f2d2445ea4ce854520731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434b2cb837a34ceedb53050320255c33" id="r_a434b2cb837a34ceedb53050320255c33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a434b2cb837a34ceedb53050320255c33">ravel</a> (const std::vector&lt; std::size_t &gt; &amp;abs_multi_index) const</td></tr>
<tr class="memdesc:a434b2cb837a34ceedb53050320255c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ravels a multi-index into a single value indexing the buffer.  <br /></td></tr>
<tr class="separator:a434b2cb837a34ceedb53050320255c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3afaa3ab384907b907acad35bb68a55" id="r_ab3afaa3ab384907b907acad35bb68a55"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#ab3afaa3ab384907b907acad35bb68a55">dtype</a> (<a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a> endianness) const</td></tr>
<tr class="memdesc:ab3afaa3ab384907b907acad35bb68a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dtype for std::wstring tensors.  <br /></td></tr>
<tr class="separator:ab3afaa3ab384907b907acad35bb68a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7b5462e0fef09897910074d44d861611" id="r_a7b5462e0fef09897910074d44d861611"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#a7b5462e0fef09897910074d44d861611">from_file</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a7b5462e0fef09897910074d44d861611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a tensor from the specified location on disk.  <br /></td></tr>
<tr class="separator:a7b5462e0fef09897910074d44d861611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dcdd9973eb737eb3d7767fe218f194" id="r_af3dcdd9973eb737eb3d7767fe218f194"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnpy_1_1tensor.html#af3dcdd9973eb737eb3d7767fe218f194">load</a> (std::basic_istream&lt; char &gt; &amp;input, const <a class="el" href="structnpy_1_1header__info.html">header_info</a> &amp;info)</td></tr>
<tr class="memdesc:af3dcdd9973eb737eb3d7767fe218f194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a tensor from the provided stream.  <br /></td></tr>
<tr class="separator:af3dcdd9973eb737eb3d7767fe218f194"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class npy::tensor&lt; T &gt;</div><p>The default tensor class. </p>
<p>This class can be used as a data exchange format for the library, but the methods and classes will also work with your own tensor implementation. The library methods require the following methods to be present in a tensor type:</p><ul>
<li><a class="el" href="classnpy_1_1tensor.html#af3dcdd9973eb737eb3d7767fe218f194">load</a></li>
<li><a class="el" href="classnpy_1_1tensor.html#a2c0907fa4f35f3dbe9ce0367448dad82">save</a></li>
<li><a class="el" href="classnpy_1_1tensor.html#ad0e71ad970c20cae0249e1837e2801cc">shape</a></li>
<li><a class="el" href="classnpy_1_1tensor.html#ad3832b2cb1c9314abdfcaac2323967ae">ndim</a></li>
<li><a class="el" href="classnpy_1_1tensor.html#aac215c34c837038ed563b0ad6b424431">dtype</a></li>
<li><a class="el" href="classnpy_1_1tensor.html#a684c3c76eebb2bed2485703829034a59">fortran_order</a></li>
</ul>
<p>As long as these are present and have the same semantics, the library should handle them in the same was as this implementation. Only certain type of tensor objects are natively supported (see <a class="el" href="namespacenpy.html#abae1d42f0957bb3a28b51128159a69c3">npy::data_type_t</a>). </p><dl class="section note"><dt>Note</dt><dd>This class is not optimized for access speed. It is intended as a simple data exchange format. Once the raw data has been extracted from the NPY or NPZ, it is recommended to convert it to a more efficient format for processing using the <a class="el" href="classnpy_1_1tensor.html#a01c366139a18b6410b69e1cde08a152d" title="A pointer to the start of the underlying values buffer.">data()</a> method. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a401aa99066711454331a8ce24101bec6" name="a401aa99066711454331a8ce24101bec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401aa99066711454331a8ce24101bec6">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a>* <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const pointer type of the tensor. </p>

</div>
</div>
<a id="a2ce0c9c2f11be941c9a14ff078561268" name="a2ce0c9c2f11be941c9a14ff078561268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce0c9c2f11be941c9a14ff078561268">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a>&amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const reference type of the tensor. </p>

</div>
</div>
<a id="a670a9d4fceac896ad00f7a60fb8b9329" name="a670a9d4fceac896ad00f7a60fb8b9329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670a9d4fceac896ad00f7a60fb8b9329">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a>* <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pointer type of the tensor. </p>

</div>
</div>
<a id="aef8c81df709fd6ceaaea5897e5a8a505" name="aef8c81df709fd6ceaaea5897e5a8a505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8c81df709fd6ceaaea5897e5a8a505">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classnpy_1_1tensor.html#accf3685dd37c104848c6187a24f0d293">value_type</a>&amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference type of the tensor. </p>

</div>
</div>
<a id="accf3685dd37c104848c6187a24f0d293" name="accf3685dd37c104848c6187a24f0d293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf3685dd37c104848c6187a24f0d293">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type of the tensor. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa89eed957cb3d7d05165a49054a18cf9" name="aa89eed957cb3d7d05165a49054a18cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89eed957cb3d7d05165a49054a18cf9">&#9670;&#160;</a></span>tensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::tensor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This will allocate a data buffer of the appropriate size in row-major order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>the shape of the tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa48d6e6c3a97ea27caf0622449fc7515" name="aa48d6e6c3a97ea27caf0622449fc7515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48d6e6c3a97ea27caf0622449fc7515">&#9670;&#160;</a></span>tensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::tensor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fortran_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This will allocate a data buffer of the appropriate size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>the shape of the tensor </td></tr>
    <tr><td class="paramname">fortran_order</td><td>whether the data is stored in FORTRAN, or column major, order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff814b1db2bab48f966bf49a4d6a4a6c" name="aff814b1db2bab48f966bf49a4d6a4a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff814b1db2bab48f966bf49a4d6a4a6c">&#9670;&#160;</a></span>tensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ac650cb70b8437300946464629f50183b" name="ac650cb70b8437300946464629f50183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac650cb70b8437300946464629f50183b">&#9670;&#160;</a></span>tensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::tensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2a576bc55c8bd02ec09797f46d74af9" name="ad2a576bc55c8bd02ec09797f46d74af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a576bc55c8bd02ec09797f46d74af9">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::iterator <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator pointing at the beginning of the tensor in memory. </p>

</div>
</div>
<a id="a65878d7b654fe3e31e01b24eb4cd215d" name="a65878d7b654fe3e31e01b24eb4cd215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65878d7b654fe3e31e01b24eb4cd215d">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::const_iterator <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator pointing at the beginning of the tensor in memory. </p>

</div>
</div>
<a id="a677e9f20de0d4a10d983a13aaa2af789" name="a677e9f20de0d4a10d983a13aaa2af789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677e9f20de0d4a10d983a13aaa2af789">&#9670;&#160;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy values from the provided vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source vector. Should have the same size as <a class="el" href="classnpy_1_1tensor.html#af6ab458c84f0549031108312804b875a">values</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a128dc5d7bea3eaba210f68c31b81a2c5" name="a128dc5d7bea3eaba210f68c31b81a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128dc5d7bea3eaba210f68c31b81a2c5">&#9670;&#160;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nitems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy values from the source to this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>pointer to the start of the source buffer </td></tr>
    <tr><td class="paramname">nitems</td><td>the number of items to copy. Should be equal to <a class="el" href="classnpy_1_1tensor.html#afdfe2df7ec8257993f958e10e7febbde">size</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01c366139a18b6410b69e1cde08a152d" name="a01c366139a18b6410b69e1cde08a152d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c366139a18b6410b69e1cde08a152d">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the start of the underlying values buffer. </p>

</div>
</div>
<a id="acae9b26c0c5d2c7c5d5f99a325c4d39e" name="acae9b26c0c5d2c7c5d5f99a325c4d39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae9b26c0c5d2c7c5d5f99a325c4d39e">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the start of the underlying values buffer. </p>

</div>
</div>
<a id="a3b4406177bbae28349fc2eacae193215" name="a3b4406177bbae28349fc2eacae193215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4406177bbae28349fc2eacae193215">&#9670;&#160;</a></span>dtype() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenpy.html#abae1d42f0957bb3a28b51128159a69c3">data_type_t</a> <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::dtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data type of the tensor. </p>
<p>This is one of the methods required by the library to read and write NPY files. </p><dl class="section return"><dt>Returns</dt><dd>the data type of the tensor </dd></dl>

</div>
</div>
<a id="aac215c34c837038ed563b0ad6b424431" name="aac215c34c837038ed563b0ad6b424431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac215c34c837038ed563b0ad6b424431">&#9670;&#160;</a></span>dtype() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::dtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a>&#160;</td>
          <td class="paramname"><em>endianness</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data type of the tensor. </p>

</div>
</div>
<a id="ab3afaa3ab384907b907acad35bb68a55" name="ab3afaa3ab384907b907acad35bb68a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3afaa3ab384907b907acad35bb68a55">&#9670;&#160;</a></span>dtype() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; std::wstring &gt;::dtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a>&#160;</td>
          <td class="paramname"><em>endianness</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of dtype for std::wstring tensors. </p>

</div>
</div>
<a id="a346e268854d182b405913911fbf8a25f" name="a346e268854d182b405913911fbf8a25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346e268854d182b405913911fbf8a25f">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::iterator <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator pointing at the end of the tensor in memory. </p>

</div>
</div>
<a id="aede3f4f51109b38a1f59bff95e196990" name="aede3f4f51109b38a1f59bff95e196990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede3f4f51109b38a1f59bff95e196990">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::const_iterator <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator pointing at the end of the tensor in memory. </p>

</div>
</div>
<a id="a684c3c76eebb2bed2485703829034a59" name="a684c3c76eebb2bed2485703829034a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684c3c76eebb2bed2485703829034a59">&#9670;&#160;</a></span>fortran_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::fortran_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the tensor data is stored in FORTRAN, or column-major, order. </p>
<p>This is one of the methods required by the library to read and write NPY files. </p><dl class="section return"><dt>Returns</dt><dd>whether the tensor is stored in FORTRAN order </dd></dl>

</div>
</div>
<a id="a7b5462e0fef09897910074d44d861611" name="a7b5462e0fef09897910074d44d861611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5462e0fef09897910074d44d861611">&#9670;&#160;</a></span>from_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a tensor from the specified location on disk. </p>

</div>
</div>
<a id="a20d4def2efb612cc8c6d8ab421601440" name="a20d4def2efb612cc8c6d8ab421601440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d4def2efb612cc8c6d8ab421601440">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value at the provided index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>the index into the tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the provided index </dd></dl>

</div>
</div>
<a id="af3dcdd9973eb737eb3d7767fe218f194" name="af3dcdd9973eb737eb3d7767fe218f194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dcdd9973eb737eb3d7767fe218f194">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnpy_1_1header__info.html">header_info</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a tensor from the provided stream. </p>
<p>This is one of the methods required by the library to read NPY files. If you implement this in a custom tensor, you will need to populate your internal data structure using the provided stream and header information. The <a class="el" href="namespacenpy.html#a847b06a33491983bfcec13f9e893f65c">npy::read_values</a> method can be used to read raw data from the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input stream </td></tr>
    <tr><td class="paramname">info</td><td>the header information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the tensor read from the stream </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenpy.html#a847b06a33491983bfcec13f9e893f65c" title="Read values from the provided stream.">npy::read_values</a> </dd></dl>

</div>
</div>
<a id="aa81804e27c8b96acbf92ab468243bf9c" name="aa81804e27c8b96acbf92ab468243bf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81804e27c8b96acbf92ab468243bf9c">&#9670;&#160;</a></span>move_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::move_from </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move values from the provided vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source vector. Should have the same size as <a class="el" href="classnpy_1_1tensor.html#af6ab458c84f0549031108312804b875a">values</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3832b2cb1c9314abdfcaac2323967ae" name="ad3832b2cb1c9314abdfcaac2323967ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3832b2cb1c9314abdfcaac2323967ae">&#9670;&#160;</a></span>ndim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::ndim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of dimensions of the tensor. </p>
<p>This is one of the methods required by the library to read and write NPY files. </p><dl class="section return"><dt>Returns</dt><dd>the number of dimensions </dd></dl>

</div>
</div>
<a id="a4f52776e4240990d1a5c25ace6ca4f04" name="a4f52776e4240990d1a5c25ace6ca4f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f52776e4240990d1a5c25ace6ca4f04">&#9670;&#160;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>the index into the tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the provided index </dd></dl>

</div>
</div>
<a id="abd7da18581a6d8001d362c5c9e3c4929" name="abd7da18581a6d8001d362c5c9e3c4929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7da18581a6d8001d362c5c9e3c4929">&#9670;&#160;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>the index into the tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the provided index </dd></dl>

</div>
</div>
<a id="aa61dc8394da8a758a4861203aa5f93d6" name="aa61dc8394da8a758a4861203aa5f93d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61dc8394da8a758a4861203aa5f93d6">&#9670;&#160;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Indices...&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable parameter index function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an index into the tensor. Can be negative (in which case it will work as in numpy) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the provided index </dd></dl>

</div>
</div>
<a id="a3e34e7f2b84c94ee871e2a72f493055e" name="a3e34e7f2b84c94ee871e2a72f493055e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e34e7f2b84c94ee871e2a72f493055e">&#9670;&#160;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Indices...&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable parameter index function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>an index into the tensor. Can be negative (in which case it will work as in numpy) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value at the provided index </dd></dl>

</div>
</div>
<a id="a9da21281dc501498c45ddde8b03d85ae" name="a9da21281dc501498c45ddde8b03d85ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da21281dc501498c45ddde8b03d85ae">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="abaa157cbf37cedb6a7d700e53717e9b7" name="abaa157cbf37cedb6a7d700e53717e9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa157cbf37cedb6a7d700e53717e9b7">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnpy_1_1tensor.html">tensor</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="aa1b03726545f2d2445ea4ce854520731" name="aa1b03726545f2d2445ea4ce854520731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b03726545f2d2445ea4ce854520731">&#9670;&#160;</a></span>ravel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::ravel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ravels a multi-index into a single value indexing the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>the multi-index value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single value in the buffer corresponding to the multi-index </dd></dl>

</div>
</div>
<a id="a434b2cb837a34ceedb53050320255c33" name="a434b2cb837a34ceedb53050320255c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434b2cb837a34ceedb53050320255c33">&#9670;&#160;</a></span>ravel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::ravel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>abs_multi_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ravels a multi-index into a single value indexing the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_multi_index</td><td>the multi-index value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single value in the buffer corresponding to the multi-index </dd></dl>

</div>
</div>
<a id="ad8d66816cf6a207a3f2fd4f5dc8a0b23" name="ad8d66816cf6a207a3f2fd4f5dc8a0b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d66816cf6a207a3f2fd4f5dc8a0b23">&#9670;&#160;</a></span>ravel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class INDEX_IT , class SHAPE_IT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::ravel </td>
          <td>(</td>
          <td class="paramtype">INDEX_IT&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SHAPE_IT&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ravels a multi-index into a single value indexing the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INDEX_IT</td><td>the index iterator class </td></tr>
    <tr><td class="paramname">SHAPE_IT</td><td>the shape iterator class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the multi-index iterator </td></tr>
    <tr><td class="paramname">shape</td><td>the shape iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single value in the buffer corresponding to the multi-index </dd></dl>

</div>
</div>
<a id="adcaf78cbfe64e16fa610642eb179ee43" name="adcaf78cbfe64e16fa610642eb179ee43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaf78cbfe64e16fa610642eb179ee43">&#9670;&#160;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a>&#160;</td>
          <td class="paramname"><em>endianness</em> = <code><a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11af78504d96ba7177dc0c6784905ac8743">npy::endian_t::NATIVE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save this tensor to the provided location on disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>a valid location on disk </td></tr>
    <tr><td class="paramname">endianness</td><td>the endianness to use in writing the tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c0907fa4f35f3dbe9ce0367448dad82" name="a2c0907fa4f35f3dbe9ce0367448dad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0907fa4f35f3dbe9ce0367448dad82">&#9670;&#160;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenpy.html#a600eb6c59cbacf81349556a92deffa11">endian_t</a>&#160;</td>
          <td class="paramname"><em>endianness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the tensor to the provided stream. </p>
<p>This is one of the methods required by the library to write NPY files. If you implement this in a custom tensor, you will need to write your internal data structure to the provided stream. The <a class="el" href="namespacenpy.html#a2a5b835e2dadd087c1ff6598ff310923">npy::write_values</a> method can be used to write raw data to the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the output stream </td></tr>
    <tr><td class="paramname">endianness</td><td>the endianness to use in writing the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacenpy.html#a2a5b835e2dadd087c1ff6598ff310923" title="Write values to the provided stream.">npy::write_values</a> </dd></dl>

</div>
</div>
<a id="a852f677cec2b73684f503b09b5d6307f" name="a852f677cec2b73684f503b09b5d6307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852f677cec2b73684f503b09b5d6307f">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>multi_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value at the provided index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multi_index</td><td>an index into the tensor </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0e71ad970c20cae0249e1837e2801cc" name="ad0e71ad970c20cae0249e1837e2801cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e71ad970c20cae0249e1837e2801cc">&#9670;&#160;</a></span>shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; size_t &gt; &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The shape of the vector. Each element is the size of the corresponding dimension. </p>

</div>
</div>
<a id="addae64781a15cfc41c1136e921ec9cf8" name="addae64781a15cfc41c1136e921ec9cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addae64781a15cfc41c1136e921ec9cf8">&#9670;&#160;</a></span>shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimensionality of the tensor at the specified index. </p>
<p>This is one of the methods required by the library to read and write NPY files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index into the shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dimensionality at the index </dd></dl>

</div>
</div>
<a id="afdfe2df7ec8257993f958e10e7febbde" name="afdfe2df7ec8257993f958e10e7febbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfe2df7ec8257993f958e10e7febbde">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of elements in the tensor. </p>

</div>
</div>
<a id="af6ab458c84f0549031108312804b875a" name="af6ab458c84f0549031108312804b875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ab458c84f0549031108312804b875a">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; <a class="el" href="classnpy_1_1tensor.html">npy::tensor</a>&lt; T &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The underlying values buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/npy/<a class="el" href="npy_8h_source.html">npy.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
